<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EMG Wheelchair — Wheels driven by EMG</title>
<style>
  :root{--bg:#071427;--panel:rgba(0,0,0,0.45);--accent:#38bdf8;--muted:#9fb6c9}
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,Arial,sans-serif;color:#e6eef8}
  #ui{position:absolute;left:14px;top:14px;z-index:40;background:var(--panel);padding:12px;border-radius:10px;max-width:360px}
  #ui h2{margin:0 0 6px 0;font-size:15px}
  .row{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  button{background:var(--accent);border:0;padding:8px 10px;border-radius:8px;color:#022;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  label{font-size:13px;color:var(--muted);min-width:80px}
  input[type=range]{width:180px}
  .small{font-size:12px;color:var(--muted)}
  #canvasWrap{position:absolute;inset:0}
  canvas{display:block;width:100%;height:100%}
  footer{position:absolute;left:14px;bottom:14px;color:var(--muted);font-size:12px}
</style>
</head>
<body>

<div id="ui">
  <h2>EMG Wheelchair — Wheels driven by EMG</h2>
  <div class="row">
    <button id="foldBtn">Fold / Unfold</button>
    <button id="playBtn" class="ghost">Pause Anim</button>
    <button id="resetBtn" class="ghost">Reset View</button>
  </div>

  <div class="small">Move the EMG sliders. A > B spins wheels forward. B > A spins backward. Hold sliders to simulate muscle activation.</div>

  <div class="row">
    <label>EMG A</label>
    <input id="emgA" type="range" min="0" max="1023" value="0">
    <div id="vA" class="small">0</div>
  </div>
  <div class="row">
    <label>EMG B</label>
    <input id="emgB" type="range" min="0" max="1023" value="0">
    <div id="vB" class="small">0</div>
  </div>

  <div class="row">
    <label>Zoom</label>
    <input id="zoom" type="range" min="0.6" max="1.4" step="0.01" value="1">
    <div id="zv" class="small">1.00x</div>
  </div>

  <div style="margin-top:6px" class="small">Tip: increase EMG A to move forward, EMG B to reverse. The wheel speed and small forward motion simulate the control mapping.</div>
</div>

<div id="canvasWrap"><canvas id="c"></canvas></div>
<footer>EMG-driven wheels — Canvas2D simulation (no WebGL).</footer>

<script>
// --------- Setup ----------
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });

function resize(){ canvas.width = canvas.clientWidth = window.innerWidth; canvas.height = canvas.clientHeight = window.innerHeight; updateCenter(); }
window.addEventListener('resize', resize);
resize();

// UI elements
const foldBtn = document.getElementById('foldBtn');
const playBtn = document.getElementById('playBtn');
const resetBtn = document.getElementById('resetBtn');
const emgA = document.getElementById('emgA'), emgB = document.getElementById('emgB');
const vA = document.getElementById('vA'), vB = document.getElementById('vB');
const zoom = document.getElementById('zoom'), zv = document.getElementById('zv');

let animRunning = true;
playBtn.addEventListener('click', ()=>{ animRunning = !animRunning; playBtn.textContent = animRunning ? 'Pause Anim' : 'Resume Anim'; });
foldBtn.addEventListener('click', ()=>{ folding = !folding; });
resetBtn.addEventListener('click', ()=>{ camX=0; camY=0; zoomVal=1; zv.textContent='1.00x'; });

// pan / zoom
let camX = 0, camY = 0, isPanning=false, lastPX=0, lastPY=0;
canvas.addEventListener('mousedown', (e)=>{ isPanning=true; lastPX=e.clientX; lastPY=e.clientY; });
window.addEventListener('mouseup', ()=> isPanning=false);
window.addEventListener('mousemove', (e)=>{ if(isPanning){ camX += (e.clientX - lastPX); camY += (e.clientY - lastPY); lastPX = e.clientX; lastPY = e.clientY; }});
canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); zoomVal *= (1 + e.deltaY * -0.0015); zoomVal = Math.max(0.4, Math.min(2.0, zoomVal)); zoom.value = zoomVal; zv.textContent = zoomVal.toFixed(2)+'x'; }, {passive:false});
zoom.addEventListener('input', ()=>{ zoomVal = Number(zoom.value); zv.textContent = zoomVal.toFixed(2)+'x'; });

// EMG display
emgA.addEventListener('input', ()=> vA.textContent = emgA.value );
emgB.addEventListener('input', ()=> vB.textContent = emgB.value );

// initial camera / scene state
let zoomVal = 1;
let folding = false;
let foldProgress = 0; // 0: open, 1: folded
let wheelSpinL = 0; // left wheel angle
let wheelSpinR = 0; // right wheel angle
let casterAngle = 0;
let tLast = performance.now();
let vehicleX = 0; // small forward/back translation for simulation

// ---------- 3D-ish helpers (simple isometric projection) ----------
function project3(x,y,z){
  const scale = 1.0 * zoomVal;
  const sx = x * scale - z * 0.8 * scale;
  const sy = y * scale - z * 0.4 * scale;
  return { x: cx + sx + camX, y: cy + sy + camY };
}

function updateCenter(){ cx = canvas.width/2; cy = canvas.height/2 + 40; }
let cx = canvas.width/2, cy = canvas.height/2 + 40;
updateCenter();

// draw helpers (rounded rect, circle, etc.)
function roundRectPath(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}
function roundRect(x,y,w,h,r,fill){
  roundRectPath(x,y,w,h,r);
  if(fill){ ctx.fillStyle = fill; ctx.fill(); }
  ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1; ctx.stroke();
}
function shadeColor(hex, percent){
  const c = hex.replace('#','');
  const num = parseInt(c,16);
  let r = (num >> 16) + percent, g = ((num >> 8) & 0xFF) + percent, b = (num & 0xFF) + percent;
  r = Math.max(0, Math.min(255, r)); g = Math.max(0, Math.min(255, g)); b = Math.max(0, Math.min(255, b));
  return '#' + ( (1<<24) + (r<<16) + (g<<8) + b ).toString(16).slice(1);
}

// ---------- Model definitions ----------
const model = {
  seat: {x:0,y:20,z:0, w:160,h:12,d:70},
  backrest: {x:0,y:60,z:-28, w:140,h:64,d:12},
  rearWheelL: {x:-80,y:20,z:-46, r:46},
  rearWheelR: {x:-80,y:20,z:46, r:46},
  casterL: {x:70,y:18,z:-22, r:14},
  casterR: {x:70,y:18,z:22, r:14},
  motorL: {x:-80,y:20,z:-46, w:22,h:18,d:18},
  motorR: {x:-80,y:20,z:46, w:22,h:18,d:18},
  joystick: {x:34,y:60,z:50},
  battery: {x:-12,y:8,z:0,w:84,h:28,d:36},
  pcb: {x:18,y:36,z:14,w:36,h:4,d:24},
  electrodes: [{x:36,y:70,z:-40},{x:44,y:70,z:-40}]
};

// ---------- Drawing primitives ----------
function drawBoxModel(x,y,z,w,h,d, fill){
  const slices = 6;
  for(let s=slices-1;s>=0;s--){
    const dz = (s / slices) * d - d*0.5;
    const p = project3(x, y - (s * 0.5), z + dz);
    const ww = w * (1 - s*0.02) * zoomVal;
    const hh = h * (1 - s*0.02) * zoomVal;
    const left = p.x - ww/2, top = p.y - hh/2;
    const shade = shadeColor(fill, -s*3);
    roundRect(left, top, ww, hh, Math.max(3,6 - s), shade);
  }
}
function drawBoxModelRotated(x,y,z,w,h,d, fill, rotX){
  const pFront = project3(x, y - Math.sin(rotX)*h*0.5, z - Math.cos(rotX)*d*0.5);
  const pBack  = project3(x, y + Math.sin(rotX)*h*0.5, z + Math.cos(rotX)*d*0.5);
  const ww = w*zoomVal, hh = h*zoomVal;
  roundRect(pBack.x - ww/2, pBack.y - hh/2, ww, hh, 6, shadeColor(fill, -8));
  roundRect(pFront.x - ww/2, pFront.y - hh/2, ww, hh, 6, fill);
}
function drawCircleModel(x,y,z,r, color){
  const p = project3(x,y,z);
  ctx.beginPath();
  ctx.fillStyle = color;
  ctx.arc(p.x, p.y, Math.max(3, r*zoomVal), 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = shadeColor(color, -25); ctx.lineWidth = 1; ctx.stroke();
}

function drawWheel(x,y,z,r, tireColor, rimColor, spin){
  const p = project3(x,y,z);
  // tire
  ctx.beginPath(); ctx.fillStyle = tireColor; ctx.arc(p.x,p.y, Math.max(6, r*zoomVal), 0, Math.PI*2); ctx.fill();
  // rim
  ctx.beginPath(); ctx.fillStyle = rimColor; ctx.arc(p.x,p.y, Math.max(3, r*0.45*zoomVal), 0, Math.PI*2); ctx.fill();
  // spokes
  ctx.strokeStyle = shadeColor(rimColor, -30);
  ctx.lineWidth = Math.max(1, Math.round(1 * zoomVal));
  const spokes = 12;
  for(let i=0;i<spokes;i++){
    const ang = spin + (i/spokes)*Math.PI*2;
    const sx = Math.cos(ang) * r*0.6 * zoomVal;
    const sy = Math.sin(ang) * r*0.6 * zoomVal;
    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+sx,p.y+sy); ctx.stroke();
  }
}
function drawWheelShadow(x,y,z,r){
  const p = project3(x,y-6,z+60);
  const grad = ctx.createRadialGradient(p.x,p.y,2,p.x,p.y,r*zoomVal*1.4);
  grad.addColorStop(0,'rgba(0,0,0,0.35)'); grad.addColorStop(1,'rgba(0,0,0,0.0)');
  ctx.fillStyle = grad; ctx.beginPath(); ctx.ellipse(p.x,p.y, r*zoomVal*1.3, r*zoomVal*0.65, 0, 0, Math.PI*2); ctx.fill();
}

// ---------- EMG → drive mapping ----------
// mapping constants
const MAX_RAD_PER_SEC = 16.0; // wheel angular velocity scale (radians/sec)
const WHEEL_RADIUS_MM = 460; // not used for physics, just for feel

// simple low-pass filter for smooth input
let filteredA = 0, filteredB = 0;
const filterTau = 0.08;

// ---------- Main render loop ----------
let lastTime = performance.now();
function renderFrame(now){
  now = performance.now();
  const dt = Math.min(0.05, (now - lastTime)/1000);
  lastTime = now;

  // read EMG inputs and low-pass filter
  const a = Number(emgA.value);
  const b = Number(emgB.value);
  filteredA += (a - filteredA) * Math.min(1, dt / filterTau);
  filteredB += (b - filteredB) * Math.min(1, dt / filterTau);

  // compute normalized [-1..1] motor command
  const normA = (filteredA / 1023);
  const normB = (filteredB / 1023);
  const drive = Math.max(-1, Math.min(1, (normA - normB))); // A-B
  // map to angular speed
  const wheelAngularSpeed = drive * MAX_RAD_PER_SEC; // rad/s

  // update wheel spin angles
  wheelSpinL += wheelAngularSpeed * dt;
  wheelSpinR += wheelAngularSpeed * dt;

  // vehicle small forward/back translation proportional to drive (pure visual)
  vehicleX += drive * 12 * dt; // model units

  // caster swivel gentle animation
  casterAngle = Math.sin(now/600) * 0.25;

  // fold smoothing
  const targetFold = folding ? 1 : 0;
  foldProgress += (targetFold - foldProgress) * Math.min(1, dt * 6);

  // update center/clear
  ctx.fillStyle = '#071427'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // ground shadow
  ctx.fillStyle = '#03121a'; ctx.fillRect(0, cy + 160, canvas.width, canvas.height - (cy + 160));

  // compute small forward offset from vehicleX
  const forward = vehicleX;

  // frame base
  drawBoxModel(model.seat.x + forward, model.seat.y - 10, model.seat.z, model.seat.w, 8, model.seat.d, '#22313b');
  // seat cushion
  drawBoxModel(model.seat.x + forward, model.seat.y, model.seat.z, model.seat.w, model.seat.h, model.seat.d, '#182935');

  // backrest tilt + fold mixing
  const tilt = (normA - normB) * 0.25; // small tilt
  const backTilt = -tilt - foldProgress * Math.PI * 0.5; // folded rotates downward
  drawBoxModelRotated(model.backrest.x + forward, model.backrest.y, model.backrest.z, model.backrest.w, model.backrest.h, model.backrest.d, '#182935', backTilt);

  // armrests
  drawBoxModel(model.seat.x + forward - 20, model.seat.y + 10, - (model.seat.d/2 + 6), 48, 6, 12, '#22313b');
  drawBoxModel(model.seat.x + forward - 20, model.seat.y + 10, (model.seat.d/2 + 6), 48, 6, 12, '#22313b');
  drawBoxModel(model.seat.x + forward - 20, model.seat.y + 14, - (model.seat.d/2 + 6), 48, 4, 14, '#182935');
  drawBoxModel(model.seat.x + forward - 20, model.seat.y + 14, (model.seat.d/2 + 6), 48, 4, 14, '#182935');

  // joystick & base
  drawBoxModel(model.joystick.x + forward, model.joystick.y - 10, model.joystick.z, 8, 60, 6, '#9fb6c9');
  drawCircleModel(model.joystick.x + forward, model.joystick.y + 20, model.joystick.z, 7, '#0ea5a4');

  // battery & PCB
  drawBoxModel(model.battery.x + forward, model.battery.y, model.battery.z, model.battery.w, model.battery.h, model.battery.d, '#0b6b63');
  drawBoxModel(model.pcb.x + forward, model.pcb.y, model.pcb.z, model.pcb.w, model.pcb.h, model.pcb.d, '#113b2f');

  // electrodes
  for(const e of model.electrodes) drawCircleModel(e.x + forward, e.y, e.z, 3.5, '#cbd5e1');

  // rear wheels & motors (use wheelSpinL / wheelSpinR)
  drawWheel(model.rearWheelL.x + forward, model.rearWheelL.y, model.rearWheelL.z, model.rearWheelL.r, '#0a0a0c', '#444', wheelSpinL);
  drawBoxModel(model.motorL.x + forward, model.motorL.y, model.motorL.z, model.motorL.w, model.motorL.h, model.motorL.d, '#21a3c8');

  drawWheel(model.rearWheelR.x + forward, model.rearWheelR.y, model.rearWheelR.z, model.rearWheelR.r, '#0a0a0c', '#444', wheelSpinR);
  drawBoxModel(model.motorR.x + forward, model.motorR.y, model.motorR.z, model.motorR.w, model.motorR.h, model.motorR.d, '#21a3c8');

  // front casters with swivel (use casterAngle)
  drawWheel(model.casterL.x + forward, model.casterL.y, model.casterL.z, model.casterL.r, '#0a0a0c', '#555', casterAngle * 8);
  drawBoxModel(model.casterL.x + forward, model.casterL.y - 14, model.casterL.z, 6, 24, 6, '#22313b');

  drawWheel(model.casterR.x + forward, model.casterR.y, model.casterR.z, model.casterR.r, '#0a0a0c', '#555', -casterAngle * 8);
  drawBoxModel(model.casterR.x + forward, model.casterR.y - 14, model.casterR.z, 6, 24, 6, '#22313b');

  // wheel shadows
  drawWheelShadow(model.rearWheelL.x + forward, model.rearWheelL.y, model.rearWheelL.z, model.rearWheelL.r);
  drawWheelShadow(model.rearWheelR.x + forward, model.rearWheelR.y, model.rearWheelR.z, model.rearWheelR.r);
  drawWheelShadow(model.casterL.x + forward, model.casterL.y, model.casterL.z, model.casterL.r);
  drawWheelShadow(model.casterR.x + forward, model.casterR.y, model.casterR.z, model.casterR.r);

  // labels & HUD
  ctx.fillStyle = '#9fb6c9'; ctx.font = '14px Inter, Arial';
  const seatP = project3(model.seat.x + forward, model.seat.y + model.seat.h/2 + 2, model.seat.z - model.seat.d/2);
  ctx.fillText('Seat', seatP.x - 20, seatP.y - 6);
  const backP = project3(model.backrest.x + forward, model.backrest.y + 6, model.backrest.z - model.backrest.d/2);
  ctx.fillText('Backrest', backP.x - 28, backP.y - 6);

  ctx.fillStyle = '#89cfff'; ctx.font = '12px Inter, Arial';
  ctx.fillText(`EMG A: ${Math.round(filteredA)}  EMG B: ${Math.round(filteredB)}  Drive: ${drive.toFixed(2)}  Wheel ω: ${(wheelAngularSpeed).toFixed(2)} rad/s`, 18, canvas.height - 18);

  // update UI numeric readouts
  vA.textContent = Math.round(filteredA);
  vB.textContent = Math.round(filteredB);

  requestAnimationFrame(renderFrame);
}

// start loop
lastTime = performance.now();
renderFrame();

// small helpers re-used (copied from previous code)
function project3(x,y,z){
  const scale = 1.0 * zoomVal;
  const sx = x * scale - z * 0.8 * scale;
  const sy = y * scale - z * 0.4 * scale;
  return { x: cx + sx + camX, y: cy + sy + camY };
}
function drawBoxModel(x,y,z,w,h,d, fill){
  const slices = 6;
  for(let s=slices-1;s>=0;s--){
    const dz = (s / slices) * d - d*0.5;
    const p = project3(x, y - (s * 0.5), z + dz);
    const ww = w * (1 - s*0.02) * zoomVal;
    const hh = h * (1 - s*0.02) * zoomVal;
    const left = p.x - ww/2, top = p.y - hh/2;
    const shade = shadeColor(fill, -s*3);
    roundRect(left, top, ww, hh, Math.max(3,6 - s), shade);
  }
}
function drawBoxModelRotated(x,y,z,w,h,d, fill, rotX){
  const pFront = project3(x, y - Math.sin(rotX)*h*0.5, z - Math.cos(rotX)*d*0.5);
  const pBack  = project3(x, y + Math.sin(rotX)*h*0.5, z + Math.cos(rotX)*d*0.5);
  const ww = w*zoomVal, hh = h*zoomVal;
  roundRect(pBack.x - ww/2, pBack.y - hh/2, ww, hh, 6, shadeColor(fill, -8));
  roundRect(pFront.x - ww/2, pFront.y - hh/2, ww, hh, 6, fill);
}
function drawCircleModel(x,y,z,r, color){
  const p = project3(x,y,z);
  ctx.beginPath(); ctx.fillStyle = color; ctx.arc(p.x, p.y, Math.max(3, r*zoomVal), 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = shadeColor(color, -25); ctx.lineWidth = 1; ctx.stroke();
}
function drawWheel(x,y,z,r, tireColor, rimColor, spin){
  const p = project3(x,y,z);
  ctx.beginPath(); ctx.fillStyle = tireColor; ctx.arc(p.x,p.y, Math.max(6, r*zoomVal), 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.fillStyle = rimColor; ctx.arc(p.x,p.y, Math.max(3, r*0.45*zoomVal), 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = shadeColor(rimColor, -30); ctx.lineWidth = Math.max(1, Math.round(1 * zoomVal));
  const spokes = 12;
  for(let i=0;i<spokes;i++){
    const ang = spin + (i/spokes)*Math.PI*2;
    const sx = Math.cos(ang) * r*0.6 * zoomVal;
    const sy = Math.sin(ang) * r*0.6 * zoomVal;
    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+sx,p.y+sy); ctx.stroke();
  }
}
function drawWheelShadow(x,y,z,r){
  const p = project3(x,y-6,z+60);
  const grad = ctx.createRadialGradient(p.x,p.y,2,p.x,p.y,r*zoomVal*1.4);
  grad.addColorStop(0,'rgba(0,0,0,0.35)'); grad.addColorStop(1,'rgba(0,0,0,0.0)');
  ctx.fillStyle = grad; ctx.beginPath(); ctx.ellipse(p.x,p.y, r*zoomVal*1.3, r*zoomVal*0.65, 0, 0, Math.PI*2); ctx.fill();
}
function roundRect(x,y,w,h,r,fill){
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if(fill){ ctx.fillStyle = fill; ctx.fill(); }
  ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1; ctx.stroke();
}
function shadeColor(hex, percent){
  const c = hex.replace('#','');
  const num = parseInt(c,16);
  let r = (num >> 16) + percent, g = ((num >> 8) & 0xFF) + percent, b = (num & 0xFF) + percent;
  r = Math.max(0, Math.min(255, r)); g = Math.max(0, Math.min(255, g)); b = Math.max(0, Math.min(255, b));
  return '#' + ( (1<<24) + (r<<16) + (g<<8) + b ).toString(16).slice(1);
}
</script>
</body>
</html>
